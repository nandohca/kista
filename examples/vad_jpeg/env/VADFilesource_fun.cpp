/*****************************************************************************

  VADFilesource_fun.cpp

  Environment Process for the VAD example

  Note: source process getting the VAD input data from a file

  Author: F. Herrera
  Institution: KTH
  Deparment: ICT/ES
  Date: 2014 April

 *****************************************************************************/

#include "kista.hpp"

#include "../vad/compacted_types.hpp"

#include "../vad/adse_defines.h"
#include "../vad/fun/vad.h"

#include "../vad/fun/typedef.h"

#include <iostream>
#include <fstream>
#include <sstream>

#define TASK_NAME TASK_VADsource

#define INFINITE_TEST_BENCH

// Not longer necessary, test name passed as a parameter from the system configuration file
//#define TEST_NAME "dtx01"

#define TEST_FOLDER "./env/dtx_tests/"
#define READ_R_H 0
#define READ_R_L 1
#define READ_SCAL_ACF 2
#define READ_R_C 3
#define READ_PTCH 4

//#define PRINT_SRC_PARSING	

extern "C"
void VADFilesource_fun() {

//------------------------------------------------
// Environment initialization code
// (to be hidden or autogenerated in the future)
//------------------------------------------------

	// retrieve references to the channels used by the task for communication
	
	// output channel references
  	IO_FIFO_BUFFER_MSG_REF(pout_r_h_1,EDGE_r_h_1);
	IO_FIFO_BUFFER_MSG_REF(pout_r_h_2,EDGE_r_h_2);
	IO_FIFO_BUFFER_MSG_REF(pout_r_l,EDGE_r_l);
	IO_FIFO_BUFFER_SHORT_REF(pout_scal_acf_1,EDGE_scal_acf_1);	
	IO_FIFO_BUFFER_SHORT_REF(pout_scal_acf_2,EDGE_scal_acf_2);
	IO_FIFO_BUFFER_MSG_REF(pout_rc,EDGE_rc_1);		
	IO_FIFO_BUFFER_SHORT_REF(pout_pitch,EDGE_pitch);	

//--------------------------
// Task initialization code
//--------------------------

	r_t r_h_comp;
	r_t r_l_comp;
	rc_t rc_comp;

	// buffers for the input data
	short r_h[9];
	short r_l[9];
	short scal_acf;
	short rc[4];
	short ptch;

	unsigned int i;
	unsigned int state_line;

	param_value_t *param_value_p;
	std::string test_name;

	ifstream vad_in_file;
	std::string file_name;
	std::string line;
	std::string token;
	std::string delimiter = " ";
	
	file_name = TEST_FOLDER;
	file_name += "vad_";
show(global_parameters);
	param_value_p = get_global_parameter("test_name");
	if(param_value_p==NULL) {
		SC_REPORT_ERROR("Env. user code: VAD source","Error retrieving test name");
	}	
	test_name = (*param_value_p)[0];

	//file_name += TEST_NAME;
	file_name += test_name;
	file_name += ".inp";
	cout << "Opening " << file_name << endl;
	
	vad_in_file.open(file_name);
	
	if( !vad_in_file.is_open() ) {
		cout << "Error: " << file_name << " not open." << endl;
		SC_REPORT_ERROR("User Code","VAD Input test-bench file not open.");
	}
	
	
#ifdef INFINITE_TEST_BENCH
#endif

	while(true) {
//--------------------------
// Task code
//--------------------------
		state_line = READ_R_H;
		
		// read next content line
		while(getline(vad_in_file,line)) {
#ifdef PRINT_SRC_PARSING			
			cout << "VADsrc:line (" << line.size() << ") : " << line << endl;	
#endif
			if(line.size()==0) continue; // empty line, looks for the next line
			
			std::stringstream linestream(line);
			
			linestream >> token;
//			if(!linestream.good()) SC_REPORT_ERROR("Env user code", "While parsing vad input. Reading first token");
			
			if(token=="--") continue;
					 // if it is a comment looks for the next line
#ifdef PRINT_SRC_PARSING	
			cout << token << " ";				
#endif
			switch(state_line) {
				case READ_R_H:
					r_h[0] = (short)atoi(token.c_str());
					for(unsigned int i=1;i<9;i++) {
						linestream >> token;
						//if(!linestream.good()) SC_REPORT_ERROR("User env code", "Error during vad input data parsing. Reading r_h");					
#ifdef PRINT_SRC_PARSING	
						cout << token << " ";						
#endif						
						r_h[i] = (short)atoi(token.c_str());
					}
					state_line = READ_R_L;
					break;
				case READ_R_L:
					r_l[0] = (short)atoi(token.c_str());				
					for(unsigned int i=1;i<9;i++) {
						linestream >> token;
						//if(!linestream.good()) SC_REPORT_ERROR("User env code", "Error during vad input data parsing. Reading r_h");					
#ifdef PRINT_SRC_PARSING	
						cout << token << " ";	
#endif					
						r_l[i] = (short)atoi(token.c_str());
					}			
					state_line = READ_SCAL_ACF;
					break;
				case READ_SCAL_ACF:
					scal_acf = (short)atoi(token.c_str());
					state_line = READ_R_C;
					break;
				case READ_R_C:
					rc[0] = (short)atoi(token.c_str());				
					for(unsigned int i=1;i<4;i++) {
						linestream >> token;
						//if(!linestream.good()) SC_REPORT_ERROR("User env code", "Error during vad input data parsing. Reading rc");					
#ifdef PRINT_SRC_PARSING						
						cout << token << ", ";						
#endif
						rc[i] = (short)atoi(token.c_str());
					}	
					state_line=READ_PTCH;
					break;
				case READ_PTCH:				
					ptch = (short)atoi(token.c_str());
					state_line = READ_R_H;
					break;
				default:
					SC_REPORT_ERROR("Env. User Code","Unexpected state while parsing vad input data.");
			}
#ifdef PRINT_SRC_PARSING				
			cout << endl;
#endif

			if(state_line==READ_R_H) { // All input data for a firing of the VAD already read 
			                           // Now we transmit all of them at once

				// SEND THE 5 INPUT DATA
				// ----------------------------------------------------

				PRINT_TASK(TASK_NAME,"send");

				for (i=0; i<9; i++) {
					r_h_comp.item[i] = r_h[i];
					r_l_comp.item[i] = r_l[i];
				}
/*
			  cout << "VADsrc: r_h = {";
			  for(unsigned int i=0;i<9;i++) cout << r_h[i] << ",";
			  cout << "}" << endl;

			  cout << "VADsrc: r_h_comp = {";
			  for(unsigned int i=0;i<9;i++) cout << r_h_comp.item[i] << ",";
			  cout << "}" << endl;
*/
				message_t msg_r_h_1(&r_h_comp,sizeof(r_h_comp));
					
				pout_r_h_1->write(msg_r_h_1);

				message_t msg_r_h_2(&r_h_comp,sizeof(r_h_comp));
				pout_r_h_2->write(msg_r_h_2);
				
				message_t msg_r_l(&r_l_comp,sizeof(r_l_comp));
				pout_r_l->write(msg_r_l);
					
				pout_scal_acf_1->write(scal_acf);
				pout_scal_acf_2->write(scal_acf);

				for (i=0; i<4; i++) {
					rc_comp.item[i] = rc[i];
				}
				message_t  msg_rc(&rc_comp, sizeof(rc_comp));
				pout_rc->write(msg_rc);
				
				pout_pitch->write(ptch);
			} // end if state_line==READ_R_H (aagin)
			
		} // end of parsing line by line

		// Place at the beginning of the file again
		// This is to allow a recurrent application of the audio sample
		// associated to the test.
		vad_in_file.clear();
		vad_in_file.seekg(0, ios::beg);

	}

}
